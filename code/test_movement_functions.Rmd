---
title: "Unit testing movement functions"
author: "Simon Mills"
date: "13/10/2020"
output: html_document
---
Notes: 

- The full raster has to have a margin of "not-permitted" (i.e. 0-valued cells), otherwise it will wrap around edges. Is it best to hard-code this? Currently do the matrix processing outside of the function, but maybe safest to either wrap this in a helper function, or stick it in the graph function directly.. 

```{r setup, include=FALSE}
library(raster); library(igraph); library(dplyr)
source("functions_igraph.R")

# rasters index cells horizontally rather than vertically, which will mess up code
# written for matrices, but plotting them without rotation and safely (by reducing
# resolution for large matrices is useful), so use this. 
plot_mat <- function(x, ...) plot(raster(x), ...)

```

# Test 1: spread of algorithm under varying gap-crossing
Note this is just isolating the mechanism of spread through the graph, with varying gap-crossing ability. This spread function however is not called directly in the main functions. 
```{r, eval=F}
# read 65*50 matrix that has "permitted movement" cells spaced contiguously, 
# 1-cell removed, and 2-cell removed
test_mat <- as.matrix(raster("../data/pikachu.png"))
test_mat[test_mat[] == 5] <- 1
test_mat[test_mat[] > 1] <-0

# for spread function
start_cells <- min(which(test_mat[] == 1))
n_row <- dim(test_mat)[1]
n_col <- dim(test_mat)[2]
permitted_cells <- which(test_mat == 1)

# run
fill1 <- spread_igraph(permitted_cells, start_cells, n_row, n_col, rule=1)
fill2 <- spread_igraph(permitted_cells, start_cells, n_row, n_col, rule=2)
fill3 <- spread_igraph(permitted_cells, start_cells, n_row, n_col, rule=3)

# fill points reached by algorithm
mat1 <- test_mat; mat1[fill1] <- 20
mat2 <- test_mat; mat2[fill2] <- 20
mat3 <- test_mat; mat3[fill3] <- 20

# save results
par(mfrow=c(2,2))
permitted_plot <- test_mat
permitted_plot[start_cells] <- 20
plot_mat(permitted_plot, asp=1, main = "Permitted movement & start")
plot_mat(mat1, asp=1, main = "Spread, 1-cell search radius")
plot_matmat2, asp=1, main = "Spread, 2-cell search radius")
plot_mat(mat3, asp=1, main = "Spread, 3-cell search radius")
```

```{r}
## test 2----
# Does function correctly track niche through time?
# create an elevational gradient
# df_gradient <- expand.grid(x = 1:n_col, y = 1:n_row) %>%
#     mutate(xy = (x*y), xy_scale = (xy-min(xy))/max(xy-min(xy)) * 1000) %>%
#     arrange(x, y)
# 
# # for passing to simulation
# ele_vec <- df_gradient$xy_scale
# start_cells <- min(which(test_mat[] == 1))
# permitted_cells <- which(permitted_movement == 1)
# n_iter <- 300
# lwr_vec <- 0 + 0:(n_iter+1)
# upr_vec <- 100 + 0:(n_iter+1)
# 
# # simulate
# ranges_sim <- sim_new_range_igraph(n_iter, ele_vec, lwr_vec, upr_vec, 
#                                    permitted_cells, start_cells, n_row, n_col, rule=2)
# 
# # save 
# png("figures/test_rangesim_rule2.png", height=200, width=110, units="mm", res=100)
# par(mfrow = c(4,2))
# plot_mat(matrix(ele_vec, ncol=n_col, nrow=n_row), main="Elevation gradient")
# mat_2 <- test_mat; mat_2[mat_2 == 1] <- ele_vec[mat_2==1]
# plot_mat(mat_2, main="Permitted movement & gradient")
# # plot results
# mat1 <- test_mat; mat1[ranges_sim[[1]]] <- 20
# plot_mat(mat1, main="t[1]")
# mat1 <- test_mat; mat1[ranges_sim[[50]]] <- 20
# plot_mat(mat1, main="t[50]")
# mat1 <- test_mat; mat1[ranges_sim[[100]]] <- 20
# plot_mat(mat1, main="t[100]")
# mat1 <- test_mat; mat1[ranges_sim[[150]]] <- 20
# plot_mat(mat1, main="t[150]")
# mat1 <- test_mat; mat1[ranges_sim[[200]]] <- 20
# plot_mat(mat1, main="t[200]")
# mat1 <- test_mat; mat1[ranges_sim[[250]]] <- 20
# plot_mat(mat1, main="t[250]")
# dev.off()

# generate gif
# library(animation)
# saveHTML({
#     for(i in seq(1, n_iter, round(n_iter/50, 0))) {
#         mat_t <- test_mat; mat_t[ranges_sim[[i]]] <- 10
#         plot_mat(mat_t)
#     }
# },title = "Simulated spread, rule=1", description = desc, verbose = FALSE)

## getting connectivity measures
# permitted_cells <- which(permitted_vec == 1)
# rule <- 1
# dat <- data.frame(x1 = rep(permitted_cells, (rule*2 + 1)^2 - 1), 
#                   x2 = get_adjacent(permitted_cells, n_row, n_col, rule)) %>%
#     filter(x2 %in% permitted_cells)
# graph <- graph_from_data_frame(dat)
# members <- components(graph)$membership %>%
#     data.frame(membership = ., id_cell = as.integer(names(.)))
# members$id_cell[members$membership %in% members$membership[members$id_cell %in% start_cells]]
```

# Test X: get all cells up-gradient from a start cell
(i.e. travelling from smaller values to larger, as is the case moving up or along an elevational gradient)
```{r}
## test 5: accessible cells ----
# get all cells that are accessible up-gradient from a start-cell
test_mat <- as.matrix(raster("../figures/test_range_shift_1.png"))

# get start cell
in_range <- which(test_mat[] == 237)
# convert start range and permitted movements to 1
test_mat[test_mat[] %in% c(0, 237)] <- 1
# convert not-permitted to 0
test_mat[test_mat[] == 255] <- 0

# for passing to function
permitted_cells <- which(test_mat[] == 1)
n_row <- dim(test_mat)[1]
n_col <- dim(test_mat)[2]

# generate gradient
df_gradient <- expand.grid(x = 1:n_col, y = 1:n_row) %>%
    arrange(x, y) %>%
    mutate(xy = 20-x) 
# for passing to simulation
ele_vec <- df_gradient$xy

# run graph and ranges
graph <- generate_graph(ele_vec, permitted_cells, n_row, n_col, rule=1)
ranges <- get_range(graph, ele_vec, start_cells = in_range)

# visualise
par(mfrow=c(2,2))
mat_tmp <- test_mat; mat_tmp[in_range] <- 2
plot_mat(mat_tmp, main="Permissible movement & start-range (green)")
mat_tmp <- test_mat; mat_tmp[] <- ele_vec
plot_mat(mat_tmp, main="Gradient")
mat_tmp <- test_mat; mat_tmp[ranges[!is.na(ordering), id_cell]] <- 2
plot_mat(mat_tmp, main="Accessed cells")
```

## Variant with connection upslope 
```{r}
## test 6: accessible cells ----
# get all cells that are accessible up-gradient from a start-cell (alternative
# version with linkage upslope)
test_mat <- as.matrix(raster("../figures/test_range_shift_2.png"))

# get start cell
in_range <- which(test_mat[] == 237)
# convert start range and permitted movements to 1
test_mat[test_mat[] %in% c(0, 237)] <- 1
# convert not-permitted to 0
test_mat[test_mat[] == 255] <- 0

# for passing to function
permitted_cells <- which(test_mat[] == 1)
n_row <- dim(test_mat)[1]
n_col <- dim(test_mat)[2]

# generate gradient
df_gradient <- expand.grid(x = 1:n_col, y = 1:n_row) %>%
    arrange(x, y) %>%
    mutate(xy = 20-x) 
# for passing to simulation
ele_vec <- df_gradient$xy

# run graph and ranges
graph <- generate_graph(ele_vec, permitted_cells, n_row, n_col, rule=1)
ranges <- get_range(graph, ele_vec, start_cells = in_range)

# visualise
par(mfrow=c(2,2))
mat_tmp <- test_mat; mat_tmp[in_range] <- 2
plot_mat(mat_tmp, main="Permissible movement & start-range (green)")
mat_tmp <- test_mat; mat_tmp[] <- ele_vec
plot_mat(mat_tmp, main="Gradient")
mat_tmp <- test_mat; mat_tmp[ranges[!is.na(ordering), id_cell]] <- 2
plot_mat(mat_tmp, main="Accessed cells")
```

# Test 7: up-gradient movement from multiple start-points
```{r}
test_mat <- as.matrix(raster("../figures/test_range_shift_3.png"))

# get start cell
in_range <- which(test_mat[] == 237)
# convert start range and permitted movements to 1
test_mat[test_mat[] %in% c(0, 237)] <- 1
# convert not-permitted to 0
test_mat[test_mat[] == 255] <- 0

# for passing to function
permitted_cells <- which(test_mat[] == 1)
n_row <- dim(test_mat)[1]
n_col <- dim(test_mat)[2]

# generate gradient
df_gradient <- expand.grid(x = 1:n_col, y = 1:n_row) %>%
    arrange(x, y) %>%
    mutate(xy = 20-x) 
# for passing to simulation
ele_vec <- df_gradient$xy

# run graph and ranges
graph <- generate_graph(ele_vec, permitted_cells, n_row, n_col, rule=1)
ranges <- get_range(graph, ele_vec, start_cells = in_range)

# visualise
par(mfrow=c(2,2))
mat_tmp <- test_mat; mat_tmp[in_range] <- 2
plot_mat(mat_tmp, main="Permissible movement & start-range (green)")
mat_tmp <- test_mat; mat_tmp[] <- ele_vec
plot_mat(mat_tmp, main="Gradient")
mat_tmp <- test_mat; mat_tmp[ranges[!is.na(ordering), id_cell]] <- 2
plot_mat(mat_tmp, main="Accessed cells")
```